<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///VARIABILI DEL GIOCATORE

//posizione iniziale
//x             = 0;                //posizione x corrente
//y             = 0;                //posizione y corrente
xprev           = x;                //perchè xprevious è lezzo
yprev           = y;                //perchè yprevious è lezzo
dirprev         = 0;                //direzione generale precedente (comprende il movimento u/d e l/r)
z               = 0;                //posizione z corrente
zhigh           = 32;               //altezza corrente personaggio
zhigh_stand     = 32;               //altezza in piedi
zhigh_crouch    = zhigh_stand/2;    //altezza da abbassati
xnew            = 0;                //x successiva in base alla velocità e direzione
ynew            = 0;                //y successiva in base alla velocità e direzione
zgravity        = 1;                //valore della gravità sull'asse z
zspeed          = 0;                //velocità attuale sull'asse z

//camera
camx            = 0;                //posizione x dove guarda la camera
camy            = 0;                //posizione y dove guarda la camera
camz            = 0;                //posizione z dove guarda la camera

//direzione
direction       = 0;                //direzione laterale dove guarda la camera
zdirection      = 0;                //direzione verticale dove guarda la camera

//velocità
max_speed       = 8;                //velocità massima corrente
stand_speed     = 8;                //velocità massima in piedi
crouch_speed    = stand_speed/2;    //velocità massima abbassato
cur_speed       = 0;                //velocità corrente (avanti e indietro)
str_speed       = 0;                //velocità corrente (laterale)
inc_speed       = 1;                //incremento velocità
dec_speed       = 1;                //decremento velocità (era 0.5)
cro_speed       = 2;                //velocità nell'abbassarsi
jump_force      = 8;                //forza iniziale del salto

//stato
is_dead         = false;            //true se morto
time_respawn    = 3;                //tempo di respawn
cur_time_respawn= 3;                //tempo di respawn attuale

//test
aim             = true;             //se false disabilita la visuale col mouse
closing         = false;            //true se sta per uscire
checkpoint_id   = noone;

//nasconde puntatore mouse
window_set_cursor(cr_none);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///TIME RESPAWN
if(cur_time_respawn &gt; 1)
{
    cur_time_respawn--;
    alarm[0] = room_speed;
}
else
{
    event_perform(ev_other, ev_user0);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CHIUDI GIOCO
if(keyboard_check_pressed(vk_enter))
{
    if(closing)
        game_end();
}

if(keyboard_check_pressed(vk_escape))
    closing = !closing


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///RESPAWN FORZATO
if(keyboard_check_pressed(ord("R")) and !global.chatting)
{
    if(!is_dead)
    {
        is_dead = true;
        cur_time_respawn = time_respawn;
        alarm[0] = room_speed;
    }
    else
    {
        cur_time_respawn = 0;
        alarm[0] = -1;
        event_perform(ev_other, ev_user0);
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MOVIMENTI/SALTO/ABBASSARSI
//var spid = point_distance(xprev, yprev, x, y);
//var dair = point_direction(xprev, yprev, x, y);
xnew = 0;
ynew = 0;

if(!global.chatting)
{
    if(!is_dead)
    {
        if(keyboard_check(ord("W")))
        {
            cur_speed += inc_speed;
            cur_speed = clamp(cur_speed, 0, max_speed);
            xnew += lengthdir_x(cur_speed, direction);
            ynew += lengthdir_y(cur_speed, direction);
        }
        if(keyboard_check(ord("S")))
        {
            cur_speed += inc_speed;
            cur_speed = clamp(cur_speed, 0, max_speed);
            xnew += lengthdir_x(cur_speed, direction -180);
            ynew += lengthdir_y(cur_speed, direction -180);
        }
        if(keyboard_check(ord("A")))
        {
            str_speed += inc_speed;
            str_speed = clamp(str_speed, 0, max_speed/2);
            xnew += lengthdir_x(str_speed, direction +90);
            ynew += lengthdir_y(str_speed, direction +90);
        }
        if(keyboard_check(ord("D")))
        {
            str_speed += inc_speed;
            str_speed = clamp(str_speed, 0, max_speed/2);
            xnew += lengthdir_x(str_speed, direction -90);
            ynew += lengthdir_y(str_speed, direction -90);
        }
        
        //salto
        if(keyboard_check_pressed(vk_space))
        {
            if(zspeed == 0)
            {
                zspeed = jump_force;
            }
        }
    }
    if(!keyboard_check(ord("W")) and !keyboard_check(ord("S")) and !keyboard_check(ord("A")) and !keyboard_check(ord("D")))
    {
        if(cur_speed &gt; 0) cur_speed -= dec_speed;
        else cur_speed = 0;
        if(str_speed &gt; 0) str_speed -= dec_speed;
        else str_speed = 0;
        if(cur_speed -dec_speed &gt; 0)//if(spid -dec_speed &gt; 0)
        {
            //xnew += lengthdir_x(spid - dec_speed, dair);
            //ynew += lengthdir_y(spid - dec_speed, dair);
            xnew += lengthdir_x(cur_speed - dec_speed, dirprev);
            ynew += lengthdir_y(cur_speed - dec_speed, dirprev);
        }
        /*else
        {
            spid = 0;
            xnew += lengthdir_x(spid, dair);
            ynew += lengthdir_y(spid, dair);
        }*/
        
        //aggiunto dopo
        if(str_speed -dec_speed &gt; 0)
        {
            xnew += lengthdir_x(str_speed - dec_speed, dirprev);
            ynew += lengthdir_y(str_speed - dec_speed, dirprev);
        }
    }
}

//crouch
if(keyboard_check(vk_control) or is_dead)
{
    zhigh -= cro_speed;                                 // &lt;----
    zhigh = clamp(zhigh, zhigh_crouch, zhigh_stand);    // &lt;----
    
    //zhigh = zhigh_crouch;
    max_speed = crouch_speed;
}
else
{
    if(scr_enh_collision(x, y, z, zhigh_stand, 0, 0) == noone)
    {
        zhigh += cro_speed;                                 // &lt;----
        zhigh = clamp(zhigh, zhigh_crouch, zhigh_stand);    // &lt;----
    
        //zhigh = zhigh_stand;
        max_speed = stand_speed;
    }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///COLLISIONI e GRAVITA'
xprev = x;
yprev = y;

//var spd = cur_speed;
var spd = point_distance(x, y, x + xnew, y + ynew);
var dir = point_direction(x, y, x + xnew, y + ynew);
var xmot, ymot;
//x = xprevious;
//y = yprevious;

for (i = 0; i &lt; 90; i += 5)
{
    xmot = x + lengthdir_x(spd, dir + i);
    ymot = y + lengthdir_y(spd, dir + i);
    idcoll = scr_enh_collision(xmot, ymot, z, zhigh, 0, 0)
    if (idcoll == noone) //(!place_meeting(xmot, ymot, obj_wall))
    {
        dirprev = point_direction(x, y, xmot, ymot);
        x = xmot;
        y = ymot;
        break;
    }

    xmot = x + lengthdir_x(spd, dir - i);
    ymot = y + lengthdir_y(spd, dir - i);
    idcoll = scr_enh_collision(xmot, ymot, z, zhigh, 0, 0);
    if (idcoll == noone) //(!place_meeting(xmot, ymot, obj_wall))
    {
        dirprev = point_direction(x, y, xmot, ymot);
        x = xmot;
        y = ymot;
        break;
    }
}

//gravità
var nearid = noone; //blocco con cui potrei collidere sotto di me
var zmax = 0;       //altezza del blocco con cui potrei collidere
for(var i=0; i&lt;instance_number(obj_wall); i++)
{
    var curid = instance_find(obj_wall, i);
    if(place_meeting(x, y, curid) and curid.z +curid.zhigh &lt;= z and curid.z +curid.zhigh &gt;= zmax)
    {
        nearid = curid;
        zmax = curid.z +curid.zhigh;
    }
}

if(z + zspeed &gt; zmax)
{
    zspeed -= zgravity;
    if(scr_enh_collision(x, y, z +zspeed, zhigh, 0, 0) == noone)
        z += zspeed;
    else
        zspeed = 0;
}
else
{
    z = zmax;
    zspeed = 0;
    
    //se il blocco su cui mi trovo si muove
    if(nearid != noone and object_is_ancestor(nearid.object_index, obj_wall_moving))
    {
        xprev = x;
        yprev = y;
        x += lengthdir_x(nearid.speed, nearid.direction);
        y += lengthdir_y(nearid.speed, nearid.direction);
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///MOVE CAMERA
if(!global.chatting &amp;&amp; !closing)//if(aim)
{
    direction += ((display_get_width()/2) -display_mouse_get_x()) * 0.2;
    zdirection += ((display_get_height()/2) -display_mouse_get_y()) * 0.2;
    zdirection = clamp(zdirection, -89, 89);
    
    display_mouse_set(display_get_width()/2, display_get_height()/2);
}

//per la visualizzare correttamente gli sprite degli altri player
global.camsin = sin(direction*pi/180);
global.camcos = cos(direction*pi/180);

/*camx = x + lengthdir_x(128, direction);
camy = y + lengthdir_y(128, direction);
camz = z + zhigh + zdirection;*/

camx = x + cos(degtorad(direction));
camy = y - sin(degtorad(direction));
camz = z + zhigh-2 + tan(degtorad(zdirection));


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONTROLLO CHECKPOINT
var c = scr_enh_collision(x, y, z, zhigh, 0, 0, obj_checkpoint);
if(c != noone and c != checkpoint_id)
    checkpoint_id = c;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONTROLLO SE ALLA FINE DEL PERCORSO
if(scr_enh_collision(x, y, z, zhigh, 0, 0, obj_end))
{
    if(global.server == 1)
        with(obj_server_controller) event_perform(ev_other, ev_user0);
    else if(global.server == 0)
        with(obj_client_controller) event_perform(ev_other, ev_user0);
    else
    {
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CONTROLLO SE NELLA LAVA
if(z &lt; 16 and !is_dead)
{
    is_dead = true;
    d3d_light_define_ambient(c_red);
    
    cur_time_respawn = time_respawn;
    alarm[0] = room_speed;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///RESPAWN
///VARIABILI DEL GIOCATORE

//posizione iniziale
if(checkpoint_id == noone)
{
    x               = obj_spawn.x;      //posizione x corrente
    y               = obj_spawn.y;      //posizione y corrente
}
else
{
    x               = checkpoint_id.x;      //posizione x corrente
    y               = checkpoint_id.y;      //posizione y corrente
}
xprev           = x;                //perchè xprevious è lezzo
yprev           = y;                //perchè yprevious è lezzo
xprevious       = x;
xprevious       = y;
dirprev         = 0;                //direzione generale precedente (comprende il movimento u/d e l/r)
z               = 80;               //posizione z corrente
zhigh           = zhigh_stand
xnew            = 0;                //x successiva in base alla velocità e direzione
ynew            = 0;                //y successiva in base alla velocità e direzione
zspeed          = 0;                //velocità attuale sull'asse z

//camera
camx            = 0;                //posizione x dove guarda la camera
camy            = 0;                //posizione y dove guarda la camera
camz            = 0;                //posizione z dove guarda la camera

//direzione
direction       = 0;                //direzione laterale dove guarda la camera
zdirection      = 0;                //direzione verticale dove guarda la camera

//velocità
cur_speed       = 0;                //velocità corrente (avanti e indietro)
str_speed       = 0;                //velocità corrente (laterale)

//stato
is_dead         = false;            //true se morto

d3d_light_define_ambient(c_white);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///START DRAW
d3d_set_projection_ortho(0,0,display_get_gui_width(),display_get_gui_height(),0);
d3d_set_hidden(false);
d3d_set_lighting(false);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DRAW
//palette
col_pal_two[0] = make_colour_rgb(97,124,115);   //sailor's blue
col_pal_two[1] = make_colour_rgb(236,197,102);  //butter
col_pal_two[2] = make_colour_rgb(254,142,44);   //orange
col_pal_two[3] = make_colour_rgb(254,142,44);   //earth
col_pal_two[4] = make_colour_rgb(37,12,7);      //qblack

//il resto
draw_set_colour(c_white);

var wnr = -1;   //winner
var grd = -1;   //grid_players
var gst = 1;    //game_status
if(global.server == 1)
{
    wnr = obj_server_controller.winner;
    grd = obj_server_controller.grid_players;
    gst = obj_server_controller.game_status;
}
else if(global.server == 0)
{
    wnr = obj_client_controller.winner;
    grd = obj_client_controller.grid_players;
    gst = obj_client_controller.game_status;
}

//se non si sta uscendo dal gioco
if(!closing)
{
    //se si è in gioco (winner = -1 e game_status != 2)
    if(wnr == -1 and gst != 2)
    {
        //aim
        if(!is_dead)
        {
            var cx = display_get_gui_width()/2;
            var cy = display_get_gui_height()/2;
            draw_line_width(cx -16, cy, cx +16, cy, 2);
            draw_line_width(cx, cy -16, cx, cy +16, 2);
        }
        
        //time respawn
        if(is_dead)
        {
            draw_set_font(fnt_inc_big);
            draw_set_halign(fa_center);
            draw_set_valign(fa_middle);
            draw_text(display_get_gui_width()/2, display_get_gui_height()/2, string(cur_time_respawn));
            
            draw_set_font(fnt_inc);
            draw_set_halign(fa_left);
            draw_set_valign(fa_top);
        }
    }
    else
    {
        //prendo il nome del vincitore
        var row_wnr = ds_grid_find_by_col(grd, 1, wnr);
        var str_wnr = grd[# 7,row_wnr];
        
        //draw vincitore
        draw_set_font(fnt_inc_big);
        draw_set_halign(fa_center);
        draw_set_valign(fa_middle);
        draw_text(display_get_gui_width()/2, display_get_gui_height()/2, "Il vincitore e'#" + str_wnr);
        
        draw_set_font(fnt_inc);
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
    }
}
else
{
    //draw vincitore
    draw_set_font(fnt_inc_big);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(display_get_gui_width()/2, display_get_gui_height()/2, "Vuoi uscire?");
    
    draw_set_font(fnt_inc);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}

//mostra nickname giocatore
var mxdist = 1024;
var collid = noone;
var dist = mxdist;

for(var i=0; i&lt;instance_number(obj_other_player); i++)
{
    var ii = instance_find(obj_other_player, i);
    if(collision_line(x, y, x +lengthdir_x(mxdist, direction), y +lengthdir_y(mxdist, direction), ii, true, false) != noone)
    {
        var cur_dist = point_distance_3d(x, y, z, ii.x, ii.y, ii.z);
        if(cur_dist &lt; dist)
        {
            collid = ii;
            dist = cur_dist;
        }
    }
}


var nocoll = true;
for(var i=0; i&lt;instance_number(obj_wall1); i++)
{
    var ii = instance_find(obj_wall1, i);
    if(collision_line(x, y, x +lengthdir_x(dist-1, direction), y +lengthdir_y(dist-1, direction), ii, true, false) != noone)
        nocoll = false;
}

if(collid != noone and nocoll)
{
    //prendo il nome del vincitore
    var row_wnr = ds_grid_find_by_col(grd, 1, collid.netid);
    var str_wnr = grd[# 7,row_wnr];
    
    draw_set_alpha(0.5);
    draw_set_colour(col_pal_two[4]);
    draw_rectangle(display_get_gui_width()/2 -128, display_get_gui_height() -96, display_get_gui_width()/2 +128, display_get_gui_height() -32, false);
    draw_set_alpha(1);
    draw_set_colour(c_white);
    draw_set_font(fnt_inc);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(display_get_gui_width()/2, display_get_gui_height() -64, str_wnr);
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
}



</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DRAW DEBUG
var spid = point_distance(xprevious, yprevious, x, y);
var dair = point_direction(xprevious, yprevious, x, y);

draw_text(display_get_gui_width() -128, 0, "fps: " + string(fps));

/*draw_text(8, 0 * 16, "z: " + string(z));
draw_text(8, 1 * 16, "zspeed: " + string(zspeed));
draw_text(8, 2 * 16, "cur_speed: " + string(cur_speed));
draw_text(8, 3 * 16, "str_speed: " + string(str_speed));
draw_text(8, 4 * 16, "max_speed: " + string(max_speed));
draw_text(8, 5 * 16, "x: " + string(x));
draw_text(8, 6 * 16, "y: " + string(y));
draw_text(8, 7 * 16, "direction: " + string(direction));
draw_text(8, 8 * 16, "zdirection: " + string(zdirection));*/

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///END DRAW
d3d_set_hidden(true);
d3d_set_lighting(true);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///CAMERA
//d3d_set_projection(x, y, 10 +z, xt, yt, 10 +zt, 0, 0, 1);
//d3d_set_projection(x, y, z +zhigh -2, camx, camy, camz, 0, 0, 1);
d3d_set_projection_ext(x, y, z +zhigh -2, camx, camy, camz, 0, 0, 1, /*65*/80, view_wview/view_hview, 1, 10000);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="80">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///test
aim = !aim;

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
